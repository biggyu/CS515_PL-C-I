# ru-compiler – Generating the LLVM IR for our Language with Control Flow Statements

This project implements a **LLVM IR** for an expression language using Rust.
The scanner&parser reads expressions from an input file, parses them according to a context-free grammar, creates parse tree, AST, DAG representation and LLVM IR.

---

## Project Structure
```
ru-compiler/
├── opt-ssa/ # Cargo project
│ ├── src/
│ │ ├── ast.rs
│ │ ├── dag.rs
│ │ ├── cfg.rs
│ │ ├── grammar.rs
│ │ ├── llvm.rs
│ │ ├── main.rs
│ │ ├── parser.rs
│ │ └── scanner.rs
│ └── Cargo.toml
├── trivial-ssa/ # Cargo project
│ ├── src/
│ │ ├── ast.rs
│ │ ├── dag.rs
│ │ ├── grammar.rs
│ │ ├── llvm.rs
│ │ ├── main.rs
│ │ ├── parser.rs
│ │ └── scanner.rs
│ └── Cargo.toml
├── build_trv.sh # Custom build script for trivial-ssa
├── build_opt.sh # Custom build script for opt-ssa
├── run_tests.sh # Custom test run script
├── test1.c # Support code to run corresponding test1.rucomp file
├── test1.rucomp # Input expression test files
├── test1.ll # LLVM IR of input expression
├── ... # Additional test cases
└── first-compiler # Built executable (generated by build script)
``` 

## Build Instructions

To compile the project and produce an executable:

```bash
sh build.sh
```

## Run Instructions

To run tests on all test#.exp files and generate test#.astdag & test#.ll"

```bash
sh run_tests.sh
```

## Compile LLVM IR

To run the LLVM IR on x86-64, run test.c file with the ll file created. If there is an error in the expression, the ll file will not be created.

```bash
clang -c first.ll -o first.o
clang test.c first.o -o test.out
./test.out
```
